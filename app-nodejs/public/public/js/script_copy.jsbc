// ⚡ Import viem functions
import { defineChain, createPublicClient, createWalletClient, http, custom } from 'https://esm.sh/viem';

// ⚡ ABI
const ABI = [
  { "name": "token_name", "type": "function", "inputs": [{ "name": "itemId", "type": "uint256" }], "outputs": [{ "type": "string" }], "stateMutability": "view" },
  { "name": "ownerOf", "type": "function", "inputs": [{ "name": "tokenId", "type": "uint256" }], "outputs": [{ "type": "address" }], "stateMutability": "view" },
  { "name": "check_rwa_copies", "type": "function", "inputs": [{ "name": "itemId", "type": "uint256" }], "outputs": [{ "type": "uint8" }], "stateMutability": "view" },
  { "name": "token_price", "type": "function", "inputs": [{ "name": "itemId", "type": "uint256" }], "outputs": [{ "type": "uint256" }], "stateMutability": "view" },
  { "name": "tokenURI", "type": "function", "inputs": [{ "name": "tokenId", "type": "uint256" }], "outputs": [{ "name": "", "type": "string" }], "stateMutability": "view" },
  { "name": "buyNFT", "type": "function", "inputs": [{ "name": "tokenId", "type": "uint256" }], "outputs": [], "stateMutability": "payable" },
  { "name": "listNFT", "type": "function", "inputs": [{ "name": "tokenId", "type": "uint256" }, { "name": "price", "type": "uint256" }], "outputs": [], "stateMutability": "nonpayable" },
  { "name": "delistNFT", "type": "function", "inputs": [{ "name": "tokenId", "type": "uint256" }], "outputs": [], "stateMutability": "nonpayable" },
  { "name": "check_rwa_PublicationPlace", "type": "function", "inputs": [{ "name": "itemId", "type": "uint256" }, { "name": "placeKey", "type": "uint8" }], "outputs": [{ "name": "", "type": "string" }], "stateMutability": "view" }
];

// ⚡ Sepolia chain config
const sepolia = defineChain({
  id: 11155111,
  name: "Sepolia Testnet",
  nativeCurrency: { decimals: 18, name: "Ether", symbol: "ETH" },
  rpcUrls: { default: { http: ["https://eth-sepolia.g.alchemy.com/v2/kJQSQD2t7qz86UosZq4_xfVP5UzWcSkM"] } },
  testnet: true
});

// ⚡ Contract address
const CONTRACT_ADDRESS = "0xae524792e12F2072CbE9Ffe1C852a3cb7c8CB4B4";

// ⚡ Create public client
const publicClienttoNet = createPublicClient({
  chain: sepolia,
  transport: http(sepolia.rpcUrls.default.http[0])
});

let client;

// ⚡ Show notification
function showNotification(message, type = "info") {
  const container = document.getElementById("notification-container");
  const notification = document.createElement("div");
  notification.className = `notification ${type}`;
  notification.textContent = message;
  container.appendChild(notification);
  setTimeout(() => notification.remove(), 4000);
}

// ⚡ Wallet button connect
const walletBtn = document.querySelector('.wallet-btn');
walletBtn.addEventListener('click', async () => {
  if (typeof window.ethereum !== "undefined") {
    try {
      const accounts = await window.ethereum.request({ method: "eth_requestAccounts" });
      const selectedAddress = accounts[0];
      client = createWalletClient({ chain: sepolia, transport: custom(window.ethereum) });
      walletBtn.innerHTML = `Wallet: ${selectedAddress.slice(0, 6)}...${selectedAddress.slice(-4)}`;
    } catch (err) {
      console.error("Connection error:", err);
      walletBtn.innerHTML = "Wallet not connected";
    }
  } else {
    const dappUrl = encodeURIComponent(window.location.href);
    window.location.href = `https://metamask.app.link/dapp/${dappUrl}`;
  }
});

// ⚡ NFT container
const nftContainer = document.getElementById('nft-container');
const totalItemsSpan = document.getElementById('total-items');

// ⚡ Render NFTs
export async function renderNFTs(maxTokens = 100) {
  let total = 0;

  for (let i = 0; i < maxTokens; i++) {
    try {
      const name = await publicClienttoNet.readContract({ address: CONTRACT_ADDRESS, abi: ABI, functionName: 'token_name', args: [BigInt(i)] });
      const owner = await publicClienttoNet.readContract({ address: CONTRACT_ADDRESS, abi: ABI, functionName: 'ownerOf', args: [BigInt(i)] });
      const copies = await publicClienttoNet.readContract({ address: CONTRACT_ADDRESS, abi: ABI, functionName: 'check_rwa_copies', args: [BigInt(i)] });
      const pictureURI = await publicClienttoNet.readContract({ address: CONTRACT_ADDRESS, abi: ABI, functionName: 'tokenURI', args: [BigInt(i)] });
      let price;
      try {
        const rawPrice = await publicClienttoNet.readContract({ address: CONTRACT_ADDRESS, abi: ABI, functionName: 'token_price', args: [BigInt(i)] });
        price = rawPrice === 0n ? "Not listed" : (Number(rawPrice) / 1e18).toFixed(4) + " ETH";
      } catch {
        price = "Not listed";
      }

      const card = document.createElement('section');
      card.className = 'nft-card';
      card.innerHTML = `
        <img class="nft-image" src="${pictureURI}" alt="NFT ${i}">
        <div class="nft-info">
          <p><b>Name:</b> ${name}</p>
          <p><b>Offline copies:</b> ${copies}</p>
          <p><b>Owner:</b> ...${owner.slice(-7)}</p>
          <p><b>Price:</b> ${price}</p>
          <p><b>tokenId:</b> ${i}</p>
          <div class="check-section">
            <input type="text" placeholder="Check publication id: __">
            <button class="check-btn" data-id="${i}">Check</button>
            <span>{Link will be here}</span>
          </div>
        </div>
        <button class="buy-btn" data-id="${i}">Buy</button>
      `;
      nftContainer.appendChild(card);

      const buyBtn = card.querySelector('.buy-btn');
      const checkBtn = card.querySelector('.check-btn');
      const checkResult = card.querySelector('.check-section span');
      const checkInput = card.querySelector('.check-section input');

      if (price === "Not listed") buyBtn.classList.add("disabled");
      else buyBtn.classList.add("active");

      checkBtn.onclick = async () => {
        const placeKey = checkInput.value.trim();
        if (!placeKey) return showNotification("Please enter publication id (placeKey)");
        if (isNaN(placeKey)) return showNotification("Publication id must be a number");
        try {
          const result = await publicClienttoNet.readContract({ address: CONTRACT_ADDRESS, abi: ABI, functionName: "check_rwa_PublicationPlace", args: [BigInt(i), Number(placeKey)] });
          checkResult.textContent = result || "No data found";
        } catch (err) {
          console.error(err);
          checkResult.textContent = "❌ Failed to fetch publication data";
        }
      };

      buyBtn.onclick = async () => {
        if (!client) return showNotification("← Please connect wallet first");
        const [addr] = await client.requestAddresses();
        const owner_item_sell = await publicClienttoNet.readContract({ address: CONTRACT_ADDRESS, abi: ABI, functionName: 'ownerOf', args: [BigInt(i)] });
        if (owner_item_sell == addr) return showNotification("You cannot buy this item from yourself, use Delist");
        if (price === "Not listed") return showNotification("This item is not listed for sale");

        const ethValue = BigInt(Math.floor(Number(price.replace(" ETH", "")) * 1e18));
        try {
          const txHash = await client.writeContract({ address: CONTRACT_ADDRESS, abi: ABI, functionName: "buyNFT", args: [BigInt(i)], account: addr, value: ethValue });
          console.log("Tx hash:", txHash);
          window.location.reload();
        } catch (err) {
          console.error(err);
          alert("Transaction failed: " + err.message);
        }
      };

      total++;
    } catch {
      break;
    }
  }

  totalItemsSpan.textContent = total;
}

// ⚡ Run render on DOMContentLoaded
document.addEventListener("DOMContentLoaded", () => renderNFTs(100));
